<!-- Describe task in general -->

<p style="text-align: justify;">
    广义方格棋盘已被一支由<a target="_blank" href="https://en.wikipedia.org/wiki/Bishop_(chess)">bishops</a> 组成的大军占领，每只象表示为一个二元组（0-基数索引）。 <code>{% if is_js %}[row, col]{% else %}(row, col){% endif %}</code>(0基数索引）的二元组。给定棋盘大小<code>n</code> 和{% if is_js %}数组{% else %}该棋盘上象的列表{% endif %} ，计算没有任何象覆盖的安全方格数。
</p>

<p style="text-align: justify;">
    我们来看看 <code>{% if is_js %}4, [[2, 3], [0, 1]]{% else %}4, [(2, 3), (0, 1)]{% endif %}</code>，即<code>11</code> 。
</p>
<p style="text-align: center;">
    <img  title="example" src="{{MEDIA}}dangerous-bishops.svg" alt="example" style="max-height: 200px"/>
</p>

<details>
    <summary><i>如果您需要提示，请点击这一行</i></summary>
    <p style="text-align: justify;"><i>
        要检查两个方格（r1，c1）和（r2，c2）是否可以在一次象移动中相互到达，表达式 abs(r1-r2)==abs(c1-c2)检查这两个方格之间的水平距离是否等于它们的垂直距离，这对于这两个方格位于同一条对角线上既是必要的也是充分的。这样就不必分别四次重写本质上相同的逻辑块，而是一次测试就能处理所有四个对角线方向。
    </i></p>
</details>

<!-- Explain input and output values -->
<p>
   <strong>输入</strong>两个参数整数 <span>({% if is_js %}number{% else %}int{% endif %})</span>和{% if is_js %}数组{% else %}列表{% endif %} <span>({% if is_js %}array{% else %}list{% endif %})</span>的列表。
</p>

<p>
   <strong>输出：</strong>整数。 
</p>

<p>
    <strong>示例：</strong>
</p>

<pre class="brush: {% if is_js %}javascript{% else %}python{% endif %}">{{init_code_tmpl}}</pre>

<!-- Here you can explain how it can be used in development -->
<!-- The section is optional -->
<!-- <p class="for_info_only">

    <strong>How it’s used:</strong>
    <i>(math is used everywhere)</i>
</p> -->

<!-- Here you can explain some constraints for input-->
<!-- The section is optional -->
<!-- <p>
    <strong>Preconditions:</strong>
    <ul>
    <li><i>both given ints should be between -1000 and 1000</i></li>
    </ul>
</p> -->
<p><i>任务取自<span>Python CCPS 109</span> 。它是由<span>Ryerson Chang School of Continuing Education</span> 教授的。<a href="https://github.com/ikokkari">Ilkka Kokkarinen</a></i></p>
